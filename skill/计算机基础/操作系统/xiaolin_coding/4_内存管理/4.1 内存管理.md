### 1. 虚拟内存

    每个进程使用独立的虚拟地址

    操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来

    程序使用的内存地址叫做（虚拟内存地址）
    硬件里面的空间地址叫做（物理内存地址）

###  2. 内存分段

    逻辑分段： 代码段， 数据段， 栈段， 堆段， 不同的应用

    虚拟地址： 段号 + 段内偏移量
            段号 查段表 可以得到 段基地址； 段集地址 + 段内偏移量

    好处：
        1. 可以产生连续的内存空间
    问题：
        1. 容易造成外部内存碎片
        2. 内存交换的效率低 （内存 通过 磁盘交换， 效率很低）

### 3. 内存分页
    分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小， 叫做页， 4kb

    虚拟内存 通过 页表 来映射 物理地址

    能解决外部内存碎片的问题， 但是会有内部内存碎片。 如果内存空间不够，可以将最近未被使用的内存页面暂时写到硬盘上，
    需要的时候，再加载进来。 一次性只交换少数的一个页或几个页，内存交换效率相对较高

    虚拟地址： 页号 + 页内偏移量
            查页表， 查询到物理页号。 物理页号加上偏移量就得到物理内存地址
    
    
    空间上的缺陷：
        32位的环境下， 虚拟地址空间共有4GB， 整个4GB空间的映射需要(100多万个页表项)4m的内存来存储页表

    多级页表：
        虚拟地址： 一级页号 + 二级页号 + 页内偏移 （需要时再创建对应的二级页表节约内存）
        64 位的系统， 通过4级页表
    TLB:
        页表缓存， 存储最常用到的几个页

#### 3.1 为什么页表必须覆盖全部虚拟地址空间
    
    1. 虚拟地址到物理地址的映射， 简化地址翻译过程。如果不覆盖的话，需要额外判断是否存在对应页表项。

    2. 进程地址空间隔离， 进程只使用自己的页表的虚拟地址

    ...

    为什么需要多级分页

    1. 减少页表的空间
    
    一级页表为什么不设置为很小的数目，而是1024或更大
    
    设置的很小会造成频繁创建二级页表，所以需要适度的选择一级页表的大小!

### 4. 段页式内存管理
    
    1. 先把程序划分为多个有逻辑意义的段
    2. 每个段划分为固定大小的页

    虚拟地址： 段号 + 页号 + 页内偏移 （这里的段号只在进程内有这个逻辑，物理内存上只分页，不分段）

### 5. linux内存布局

    Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。

    Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），
    也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，
    所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

    linux操作系统中， 虚拟地址空间内部又被分为内核空间和用户空间两部分
    32位系统， 内核空间占用1g, 剩下的3g是用户空间。
    
    每个进程的内核空间其实关联的都是相同的物理内存。

    
    用户空间 先分为多个段：
    代码段
    数据段
    BSS段
    堆段
    栈段
    ...


### 6. 总结

    1. 为什么要有虚拟内存？
        进程之间的内存地址相互隔离，不收影响； 应用程序不用关心真实的物理内存地址；
        进程可以使用超过物理内存大小的内存，通过硬盘暂时存储。

    2. 什么是内存交换技术？
        操作系统将不常使用的内存暂时放到硬盘，需要的时候再装载回物理内存。

    3. 什么是内存分段？
        根据程序的逻辑角度，分为栈段，堆段，数据段等。
    
    4. 什么是内存分页？
        把虚拟内存和物理空间分为固定大小的页，解决了外部内存碎片的问题，提高了内存交换的效率

    5. 为什么需要多级页表？
        防止页表过大，浪费空间

    linux系统主要采用了分页处理，linux吧所有段的基地址设为0，屏蔽了CPU段地址的概念。
    linux系统中进程的用户态的虚拟内存空间使用了分段的逻辑。