### 1. 虚拟内存的作用

    1. 进程之间的内存地址相互独立
    2. 虚拟内存可以使得进程的运行内存超过物理内存大小
    3. 提供内存访问方面的安全性控制

### 2. 系统内存紧张时，会发生什么

    用户态： 通过页表访问物理内存访问不到，触发缺页中断，交给内核态

    内核态： 检查是否有空闲的物理内存，若没有，则依次进行回收内存：
            1. 后台内存回收， 异步的
            2. 直接内存回收， 同步的 （会阻塞进程的执行）

            内存回收后，仍然不够。 则触发OOM（out of memory）

### 3. 哪些内存可以被回收

    文件页： 内核缓存的磁盘数据（buffer） 内核缓存的文件数据（cache）. 干净页直接释放内存，脏页先写回磁盘再释放内存。

    匿名页： 没有载体。通过linux的 Swap机制

    通过LRU算法

### 4. 回收内存伴随着磁盘IO,如何降低影响

    1. 调整文件页和匿名页的回收倾向
    /proc/sys/vm/swappiness 数值越大，越积极使用SWAP。 数值越小，越消极使用swap. 建议设置为0

    2. 尽早触发 kswapd内核线程异步回收内存
    sar -B 1 可以看回收内存的指标。 可以通过设置/proc/sys/vm/min_free_kbytes 增大一点

### 5. 如何保护一个进程不被OOM杀掉呢
    /proc/[pid]/oom_score_adj 调低这个值

在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：
如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；

