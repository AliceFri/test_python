

### 1. 虚拟内存地址

    64位虚拟地址：  9位全局页目录项 + 9位上层页目录项 + 9位中间页目录项 + 9位页表项 + 12位页内偏移

### 2. 为什么要使用虚拟内存地址

    1. 进程之间隔离，各自使用自己的虚拟内存
    2. 进程能使用比物理内存更大的虚拟内存（利用 swap技术）

### 3. 进程虚拟内存空间
    64bit

    canonical address 空洞 0xffff800000000000 -- 0x00007ffffffff000  (因为虚拟地址只需要用到48位)

    内核空间        128t
    栈
    文件映射与匿名映射区
    堆
    BSS段
    数据段
    代码段

    除了内核空间以外的被合并称为用户态空间， 代码段，数据段，BSS段被提前确定。 栈，mmap, 堆可动态扩展


### 4. linux进程虚拟内存空间

    64位机器， 前16位如果是 0000 代表用户态， 如果是FFFF 代表是内核态， 中间的为 canonical address 空洞 0xffff800000000000 -- 0x00007ffffffff000 

### 5. 进程虚拟内存空间的管理
    1. 进程的结构task_struct有个内存描述符mm_struct结构。
    fork 子进程在创建出来之后，它的虚拟内存空间会和父进程的虚拟内存空间一模一样（拷贝）。
    vfork/clone  子进程在创建出来之后，它的虚拟内存空间会和父进程的虚拟内存空间一模一样（共享）。（线程）
    
    是否共享地址空间几乎是进程和线程之间的本质区别。
    Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已。

    内核线程和用户态线程的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。

    当一个内核线程被调度时，它会发现自己的虚拟地址空间为 Null，虽然它不会访问用户态的内存，但是它会访问内核内存，
    聪明的内核会将调度之前的上一个用户态进程的虚拟内存空间 mm_struct 直接赋值给内核线程，因为内核线程不会访问用户空间的内存，
    它仅仅只会访问内核空间的内存，所以直接复用上一个用户态进程的虚拟地址空间就可以避免为内核线程分配 mm_struct 和相关页表的开销，
    以及避免内核线程之间调度时地址空间的切换开销。

    ...

### 6. 程序二进制文件如何映射到虚拟内存空间中

    磁盘文件elf文件中的Section会被映射到段segment
    .text .rodata 等一些只读的section 会被映射到一个只读可执行的 segment(代码段）
    .data .bss 等一些可读写的 section, 会被映射到一个具有读写权限的 segment(数据段， BSS段)

### 7.  内核虚拟内存空间

    内核态虚拟内存空间

    直接映射区中的映射关系是一比一映射。映射关系是固定的不会改变。
    动态映射区
    永久映射区
    固定映射区
    临时映射区
    
    
    