### 互斥与同步

    互斥： 一个线程在临界区执行时，其他线程应该被阻止进入临界区

    同步： 就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。


    锁： 加锁，解锁操作
    信号量： P, V操作

    锁，能解决线程互斥问题
        自旋锁： 一直自旋，直到锁可用。（缺点，获取不到锁的时候自旋，浪费CPU性能）
        无等待锁： 当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行

    信号量： （表示资源的数量）
        P: -1， 如果值 <0 则阻塞， 否则继续， P操作会堵塞
        V: +1,  如果值 < 1,则唤醒一个等待中的线程， V操作不会堵塞

    操作系统实现的信号量， PV函数具有原子性。

    信号量初值为1， 用于实现互斥
    信号量初值为0， 用于实现同步

### 生产者-消费者问题
    1. 缓冲区是临界代码， 需要互斥
    2. 缓冲区空时，消费者需等待；缓冲区慢时，生产者得等待。 需要同步

    semaphore mutex = 1;    // 互斥信号量
    semaphore emptyBuffers = N;  // 空槽数量
    semaphore fullBuffers = 0;  // 满槽数量

### 哲学家就餐问题
    
    1. 拿左边筷子 2. 拿右边筷子 3. 就餐 4. 放下左边筷子 5. 放下右边筷子
    如何防止死锁
        1. 每次只让一个哲学家进餐 （进餐速度慢）
        2. 让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」
        妙，可以先想两个人，很容易想到

### 读者-写者问题

    读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。

    读-读 允许； 读-写 互斥； 写-写 互斥；

    semaphore wMutex = 1;    // 写互斥
    semaphore rCount = N;  // 空槽数量

    读优先/写优先/公平
    