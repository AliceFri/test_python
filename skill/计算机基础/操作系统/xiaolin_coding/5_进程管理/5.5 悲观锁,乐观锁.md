###  互斥锁 自旋锁

    互斥锁 加锁失败后，线程会释放CPU给其他线程；

    自旋锁 加锁失败后，线程会忙等待，直到它拿到锁；


    互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。会有两次线程上下文切换的成本。


    如果被锁住的代码执行时间很短，或者预期等锁时间很短，就应该选用自旋锁，否则使用互斥锁。

    
    自旋锁通过CPU提供的CAS函数实现，在用户态完成加锁和解锁操作，不会主动产生线程上下文切换。CAS将查看锁状态和加锁合并为原子操作

    
    自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，
    但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，
    所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。

### 读写锁

    它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。

    读写锁适用于能明确区分读操作和写操作的场景。

    读优先， 写优先， 公平读写锁

### 乐观锁 与 悲观锁

    互斥锁， 自旋锁， 读写锁 都属于悲观锁。

    悲观锁，认为冲突的概率比较高，所以访问共享资源前，先要上锁

    乐观锁，认为冲突的概率比较低， 先修改为共享资源，再验证这段时间内有没有冲突，如果有冲突，再放弃本次操作。

    在线文档就是乐观锁的典型例子。
    Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。

    乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，
    所以只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。
    
    CAS是乐观锁， 基于CAS实现的自旋锁是悲观锁
