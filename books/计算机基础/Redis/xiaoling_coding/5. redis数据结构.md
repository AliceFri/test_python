### 1. 键值对数据库是怎么实现的

    哈希表保存所有键值对；

    哈希表其实就是一个数组，数组中的元素叫做哈希桶。

    数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针

    dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， 
    key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。

### 2. SDS 
    
    String的底层实现，加了一个len属性，获取长度为O(1)时间复杂度。

    len
    alloc, 分配给字符数组的空间长度
    flags， sds类型
    buf[]

    优点： 1. 可以读取/存储二进制文件 2. 不会有分配空间不足导致溢出的问题 3. O(1)时间复杂度获取字符串长度 
    扩容规则： 如果小于1m， 则按翻倍扩容； 超过1m，则每次分配为newlen + 1m；

    之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间; 比如
    sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t； sdshdr32 则都是 uint32_t；

### 3. 链表

    Redis 的 List 对象的底层实现之一就是链表

    双向链表， 且在双向链表的基础上封装了list数据结构， 
    head*
    tail*
    len
    ...   指向 双向链表的头节点和尾节点

    优点：   头插/尾插时间复杂度O(1) 获取链表数目时间复杂度O(1)
            双向链表，可以往前遍历/往后遍历。 
            
    缺点：   内存不连续，无法很好的利用CPU缓存
            保存指针，内存开销很大

### 4. 压缩列表

    ziplist

    紧凑型， 占用一块连续的内存空间
        优点： 内存友好， 有效利用cpu缓存
        缺点：   效率低， 不能保存过多元素
                新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。

    查找第一个元素和最后一个元素O(1) 其他元素需要逐个查找。
    zlbytes zltail zllen entry1 ... entryN zlend
    entry:  prevlen encoding data

    连锁更新问题： 1， 根据数据大小和类型进行不同的空间大小分配的设计思想
                2. 压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。
                3. 而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，
                    导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。

### 5. 哈希表

    哈希表优点在于，它能以 O(1) 的复杂度快速查询数据；
    Redis 采用了「链式哈希」来解决哈希冲突，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，
    形成链接起，以便这些数据在表中仍然可以被查询到。
    
##### rehash

    1. 给哈希表2 分配空间， 一般会比哈希表1 大 2倍
    2. 将 哈希表1 的数据迁移到哈希表2中
    3. 迁移完成后， 哈希表1的空间释放，哈希表1和哈希表2交换名称。

    如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求。

##### 渐进式rehash
    
    给「哈希表 2」 分配空间；
    在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，
    Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上；
    随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。

    这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。
    在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。

##### rehash 触发条件
    
    负载因子。 哈希表已保存节点数量/哈希表大小

    负载因子大于1时， 若没有bgsave bgrewirteaof等命令。会执行rehash
    负载因子大于5时， 执行rehash操作。

### 6. 整数集合

    整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。

### 7. 跳表

    zset, 支持 o(logN)复杂度的节点查找

    Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，
    而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。

    哈希表只是用于以常数复杂度获取元素权重


    redis 调表创建节点时 随机level层数。 相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。

    为什么用跳表不用平衡树？

        内存占用上更灵活， 平衡树每个节点包含两个指针， 跳表平均每个节点的指针数更少

        范围查找时， 跳表比平衡树操作更简单

        实现难度上， 跳表比平衡树要简单的多。