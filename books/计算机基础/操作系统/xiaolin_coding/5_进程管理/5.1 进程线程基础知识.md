### 1. 进程

    资源分配的最小单位

    并发： 单核时分复用
    并行： 多核同时进行

#### 1.1 进程的状态
    运行状态 Running
    就绪状态 Ready
    阻塞状态 Blocked
    创建状态 New
    结束状态 Exit

    Null -> 创建状态： 一个新进程正在被创建
    创建状态 -> 就绪状态： 创建完成后，转为就绪状态
    就绪状态 -> 运行状态： 被cpu调度运行
    运行状态 -> 就绪状态: 时间片用完
    运行状态 -> 结束状态： 进程运行结束
    运行状态 -> 阻塞状态: 等待事件
    阻塞状态 -> 就绪状态: 事件完成

    通常会把阻塞状态的进程的物理内存空间换出到硬盘，需要再次运行的时候，再换回为内存 （挂起状态）
    分为 阻塞挂起状态， 就绪挂起状态

    sleep. ctrl+z. 内存空间不足会导致进程挂起

#### 1.2 进程的控制结构 PCB process control block
    PCB是进程存在的唯一标识
    
    pid, user, status, 优先级， 资源分配清单， cpu相关信息

    pcb通常通过链表的形式组织，相同状态的进程链在一起，组成各种队列

#### 1.3 进程的控制

    创建进程：
        1. 申请空白的PCB， 向PCB写入信息
        2. 为该进程分配资源
        3. 插入到就绪队列

    终止进程： 正常结束， 异常结束， 外界干预kill掉
        子进程被终止时，需要把继承的资源还给父进程。 父进程终止时， 子进程变为孤儿进程，会被1号进程收养。
        僵尸进程是子进程结束时，父进程没有获取子进程的信息，僵尸进程除了占用进程描述符外,不会再占用任何系统资源。
        1. 查到PCB
        2. 结束执行状态
        3. 将其子进程交给1号进程接管
        4. 将该进程所拥有的的全部资源归还给os
        5. 将其从pcb所在队列中删除
    阻塞进程
        1. 找到PCB
        2. 保护现场， 转为阻塞状态
        3. 插入到阻塞队列中去
    唤醒进程
        进程调用了阻塞语句，则必有一个与之对应的唤醒语句。 阻塞进程的相反过程

#### 1.4 进程的上下文切换

    cpu切换进程，称为进程的上下文切换。

    进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源

    进程的上下文切换只能发生在内核态。

    通常会将交换的信息保存在进程的PCB， 后续从PCB中取出上下文，恢复到cpu中。

-------

### 2. 线程

    CPU调度的最小单位，线程是进程的一条执行流程，线程能共享进程的资源
    
    一个进程中可以同时存在多个线程
    各个线程之间可以并发执行
    各个线程之间可以共享地址空间和文件等资源

### 3. 线程与进程的比较

    1. 进程是资源分配的单位， 线程是CPU调度的单位
    2. 进程拥有一个完整的资源平台， 线程共享平台志愿，自身只独享必不可少的寄存器和栈等信息
    3. 线程同样具有 就绪 阻塞 运行三种基本状态，同样有状态转移
    4. 线程能减少并发执行的时间和空间开销

    多线程比多进程的优势：
    1. 线程创建、终止比进程更快
    2. 同一个进程内的线程切换比进程切换快
    3. 线程之间交互比进程之间交互快且方便

#### 3.1 线程的上下文切换
    两个线程属于同一个进程，切换时只需要切换线程的私有数据
    两个线程属于不同的进程，切换过程等同于进程的上下文切换


### 4. 协程

    协程又被称为用户线程， 在用户态中创建， 不由操作系统管理，由应用自身管理

    用户线程： 协程， 用户态创建
    内核线程： 内核管理的线程
    轻量级进程： 在内核中来支持用户线程

    用户线程是基于用户态的线程管理库来实现的TCB， 多个用户线程 对应一个 os线程

    优点：
        1. 减少用户态和内核态的切换。 快
    缺点：
        1. 得到的时间片可能较少
        2. 需自身实现TCB，实现复杂

    LWP(轻量级进程): 协助支持用户线程 ...

### 5. 调度
    时间片用完时（时钟中断）， 中断， 会触发调度

#### 5.1 调度算法

    1. 先来先服务（非抢占式（没有中断））    FCFS

    不利于短作业，利于长作业

    2. 最短作业优先  SJF

    利于短作业， 不利于长作业

    3. 高响应比优先调度算法
    
    理想型， 很难实现，因为需要预估进程运行的时间

    4. 时间片轮转算法 RR

    5. 最高优先级调度算法

    6. 多级反馈队列调度算法 （时间片轮转算法 + 最高优先级算法）
        设置了多个队列， 每个队列不同的优先级， 优先级越高时间片越短。
        新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，
        如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；