

### 1. Socket模型

    创建socket的时候， 可以指定网络层使用的是IPv4,IPv6  传输层使用的是TCP还是UDP

    服务端与客户端 一对一通信


### 2. 多进程模型

    服务端的 主进程负责监听客户的连接， 连接完成后，fork一个子进程， 子进程创建socket 读写

    并发数 100左右

### 3. 多线程模型

    线程池

### 4. IO多路复用

    一个进程 维护多个Socket

    我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，
    进程可以通过一个系统调用函数从内核中获取多个事件。


### 5. select

    将已连接的socket都放到一个文件描述符集合， 让内核遍历文件描述符是否有事件产生。
    
    再将文件描述符集合拷贝回用户态， 遍历找到可读写的socket，进行处理。

    select使用固定长度BitsMap，表示文件描述符集合， 只能监控1024个socket

### 6. poll

    poll不再使用BitsMap来存储文件描述符集合， 使用动态数组，以链表形式来组织。
    突破了select文件描述符个数限制，当然还是会受到系统文件描述符限制

    但是 poll 和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，
    因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，
    而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。

### 7. epoll

    epoll 使用红黑树来跟踪进程所有待监测的文件描述符（为什么用红黑树， 方便增加删除监测的socket）
    select/poll 每次监测，都要传给内核，epoll可以保存在内核。

    epoll 使用事件驱动，内核里维护了一个链表来记录就绪事件
    返回时只会返回就绪的socket. select/poll会全部返回，然后需要轮询

    
    边缘触发:
        epoll_wait 中 只苏醒一次，即使数据在内核中没有被读取完，也不会再次属性

    水平触发：
        epoll_wait 会不断的提醒，直到数据被读取完

    select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。

    使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用，Linux 手册关于 select 的内容中有如下说明：