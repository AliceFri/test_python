### 1. TCPP基本认识

    源端口号 + 目的端口号    32位
    序列号                 32位
    确认应答号              32位
    首部 4 保留 6 URG|ACK|PSH|RST|SYN|FIN(标记位6) 窗口大小 16
    校验和 16 紧急指针 16
    选项（长度可变）
    数据

    序列号： 建立连接时计算机随机生成初始值， SYN包传给接收端主机，每发送一次，累加一次该数据字节数大小， 用来解决乱序问题
    
    确认应答号： 下一次期望收到的数据的序列号， 发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题

    控制位：
        ACK： 确认应答标记， 除了SYN包之外必须设置为1
        RST： 强制断开连接标记
        SYN： 希望建立连接， 序列号设置初始值
        FIN:  希望断开连接
        
    TCP工作在传输层，在IP协议所在的网络层之上，是面向连接的，可靠的，基于字节流的传输层通信协议

    面向连接： 一对一建立连接才能通信， 不能向udp一个主机同时向多个主机发送消息。

    可靠的： TCP保证数据的完整传输

    字节流： 用户消息通过TCP协议传输时， 消息会被分成多组TCP报文，如果接收方的程序如果不知道消息的边界，就无法读出有效的消息。而且
    若接收端先收到了后面的报文，不能扔给应用层去处理。

#### 1.1 什么是TCP连接

    用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。
    socket信息， 序列号， 窗口大小等共识

#### 1.2 UDP和TCP有什么区别
    
    UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。

    UDP 协议真的非常简，头部只有 8 个字节（64 位)  源端口号 + 目标端口号 + 包长度 + 校验和 

    连接： tcp面向连接， udp 无连接
    服务对象： tcp 一对一点对点， udp支持一对多，多对一， 多对多，一对一
    可靠性： tcp可靠，无差错，不丢失，不重复，按序到达。 udp不可靠
    拥塞控制，流量控制： tcp有， udp没有
    首部开销： tcp开销大， udp开销小
    传输方式： tcp基于字节流，没有边界； udp一个包一个包的发送，有边界，但是可能丢包和乱序。
    分片不同： tcp基于MSS大小分片，传输层分片组装； UDP基于MTU大小，IP层分片组装。
    应用场景： tcp: http等， udp: DNS, SNMP, 多媒体通信， 广播通信。

#### 1.3 UDP头部没有首部长度， 而TCP有
    
    TCP首部长度可变， udp首部长度不可变，固定为8个字节

#### 1.4 UDP头部有包长度， TCP没有包长度字段
    
    TCP数据的长度 = IP总长度 - IP首部长度 - TCP首部长度， 可以计算得到。

#### 1.5 TCP和UDP可以使用同一个端口吗

    可以， TCP+端口 可以 区分 UDP+端口
    

### 2. TCP连接建立

    服务端 从 close 态 转为 listen 态
    
    1. 客户端 发给服务端 SYN seq_num=client_isn     客户端转为 SYN_SENT
    
    2. 服务端 发给客户端 SYN + ACK ack_num=client_isn+1 seq_num=server_isn   服务端转为 SYN_RCVD

    3. 客户端 发给服务端 ACK ack_num=server_isn+1
        客户端 和 服务端 转为 ESTABLISHED

    第三次握手是可以携带数据的，前两次握手是不可以携带数据的。

#### 2.1 为什么需要三次握手

    三次握手才能保证双方具有接收和发送的能力

    1. 避免重复的历史连接
        如果两次连接，服务端会被客户端syn攻击，会建立历史连接的初始化连接  
        服务端重复接受无用的连接请求 SYN 报文，而造成重复分配资源。
    2. 同步双方初始序列号
        序列号可以去除重复的数据，可以按序接收，可以确认哪些数据对方已收到
        只有一来一回最少三步，才能确保双方的初始序列号能被可靠的同步

#### 2.2 为什么每次建立TCP连接时， 初始化的序列号要求不一样
    1. 防止历史报文被下一个相同四元组的连接接收
    2. 安全性更高
    
#### 2.3 IP层会分片，TCP层为什么还需要 MSS

    MTU：一个网络包的最大长度，一般为1500字节
    MSS： 出去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度

    因为IP层MTU比较大，如果一个IP分片丢失，整个 IP 报文的所有分片都得重传。

    所以tcp不适用IP分片， 而使用TCP分片，这样即使丢失一个分片，也只用重发一个MSS

#### 2.4 握手丢失
    第一次握手丢失： 客户端超时重传，重传的SYN报文的序列号是一样的。（每次超时的时间是上一次的两倍）
    第二次握手丢失： 客户端超时重传 SYN，服务端也超时重传 SYN+ACK
    第三次握手丢失： 服务端重传 SYN + ACK， 客户端收到 SYN + ACK时重传ACK。


#### 2.5 SYN攻击，如何避免SYN攻击
    大量的向服务端发送SYN报文，服务端很多连接都会处于 SYN_RCVD 状态。

    半连接队列： 处于 SYN_RCVD 状态的连接
    Accept队列： 处于 ESTABLISHED 状态的连接
    
    SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，
    后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。
    
    1. 调大网卡缓存包的大小，增大半连接队列值
    2. 开启net.ipv4.tcp_synccookies. 可以绕过半连接建立连接
    3. 较少服务端SYN+ACK重传次数

-----------------

### 3. TCP 断开连接

    1. 主动发起方  发送 FIN包， 发起方从 ESTABLISHED -> FIN_WAIT_1 状态
    2. 接收方  回   ACK， 被动方 从 ESTABLISHED -> CLOSE_WAIT， 发起方收到后 FIN_WAIT_1 -> FIN_WAIT_2
    3. 被动接受方  发送 FIN包， CLOSE_WAIT -> LAST_ACK
    4. 发起方 发送 ACK 包， FIN_WAIT_2 -> TIME_WAIT
    5. 被动方收到 ACK 变为 LAST_ACK->CLOSE, 主动方 2msl TIME_WAIT->CLOSE
    
    每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。主动关闭连接的，才有 TIME_WAIT 状态.

#### 3.1 为什么需要4次回收
    
    因为服务端和客户端都需要一次FIN和ACK，才能保证双方都同意断开连接。
    tcp延迟确认机制且被动方也没有东西要发送，可以变为3次挥手。

    第一次挥手丢失： 超时重传，超过次数后，会直接进入close状态
    第二次挥手丢失： 客户端会触发超时重传，服务端收到后会接着发ACK。 客户端超时次数到达时会直接进入close状态。
    第三次挥手丢失： 服务端发出FIN丢失后，会触发超时重传，重传失败后直接进入close状态， 客户端fin_wait2定时器超时进入close状态
    第四次挥手丢失： time_wait阶段， 服务端会重发fin报文，客户端收到fin报文后发ACK。收到fin后（重置2msl定时器）

#### 3.2 为什么是2msl
    msl： tcp报文最长生存时间,超过这个时间报文将被丢弃
    ttl:  ip路由跳数，跳数为0时数据将被丢弃，发送ICMP报文通知源主机
    
    2MSL： 允许报文丢失一次，第四次挥手丢失。重发的FIN会在2个MSL内到达。
    2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，
    客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。

    足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。

#### 3.3 为什么需要TIME_WAIT状态

    1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收
    2. 保证双方都能被正确的关闭（而不是通过RST去关闭）


#### 3.4 TIME_WAIT过多有什么危害
    1. 占用资源（内存，cpu, 端口）
    
    优化：
    1. net.ipv4.tcp_tw_reuse. 复用time_wait连接。
    2. 可以设置跳过TIME_WAIT状态

    TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它

    服务器出现大量TIME_WAIT的原因（服务器主动断开了很多连接）
    1. 关闭了http长连接， 服务端主动断开连接.客户端和服务端都开启 HTTP Keep-Alive 机制。
    2. http长连接超时， nginx 提供的 keepalive_timeout（长连接超时时间）
    3. http长连接的请求数量达到上线  nginx 的 keepalive_requests

#### 3.5 CLOSE_WAIT 大量出现的原因

    被动关闭方，
    当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。
    
    1. 创建服务端 socket，bind 绑定端口、listen 监听端口
    2. 将服务端 socket 注册到 epoll
    3. epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket
    4. 将已连接的 socket 注册到 epoll
    5. epoll_wait 等待事件发生
    6. 对方连接关闭时，我方调用 close

#### 3.6 如果已经建立了连接，客户端突然出现故障了怎么办

    TCP 保活机制， 
    定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，
    TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，
    该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，
    则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

    服务端进程崩溃，
    内核会回收该进程的所有TCP连接资源，发送4次回收。


#### 4. Socket编程
    1. 服务端和客户端初始化 socket，得到文件描述符；
    2. 服务端调用 bind，将 socket 绑定在指定的 IP 地址和端口;
    3. 服务端调用 listen，进行监听；
    4. 服务端调用 accept，等待客户端连接；
    5. 客户端调用 connect，向服务端的地址和端口发起连接请求；
    6. 服务端 accept 返回用于传输的 socket 的文件描述符；
    7. 客户端调用 write 写入数据；服务端调用 read 读取数据；
    8. 客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，
        待处理完数据后，服务端调用 close，表示连接关闭。

    listen的时候参数backlog  accpet 队列长度 = min(backlog, somaxconn)。




    