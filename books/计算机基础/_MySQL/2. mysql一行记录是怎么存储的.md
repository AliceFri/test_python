### MySQL 一行记录是怎么存储的


#### 1. mysql的数据存放在哪个文件

    db.opt 存储当前数据库的默认字符集和字符校验规则
    t_order.frm     表结构信息
    t_order.ibd     表数据信息

#### 2. 表空间文件的结构是怎么样的

    段： 索引段 + 数据段 + 回滚段
    区： 1M, 64页， 更好的利用顺序IO
    页： InnoDB的数据是按 页 为单位来读写的，每个页大小16kb
        数据页 undo日志页 溢出页等等
    行： 数据库中的记录都是按行来存放的。

#### 3. InnoDB行格式

##### 3.1 COMPACT 行格式

    变长字段长度列表 + null值列表 + 记录头信息 + row_id + trx_id + roll_ptr + 列值

###### 记录的额外信息

    变长字段长度列表     varchar
        这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放
        为什么逆序：
            1. next_record指针 向左读就是记录头信息， 向右读就是真实数据
    
    NULL值列表
        存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。
    当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。

    记录头信息：
        delete_mask: 标记是否删除
        next_record: 下一条记录的位置
        record_type: 记录类型，普通记录/非叶子节点记录/最小记录/最大记录

##### 记录的真实数据

    row_id: 如果建表的时候指定了主键和唯一约束列，就没有row_id, 既没有主键又没有唯一约束
            就会添加row_id 隐藏字段 6个字节

    trx_id: 事务ID， 6个字节
    
    roll_pointer: 记录上一个版本的指针， 用来实现MVCC机制

----

### varchar(n) 中n 最大为多少

    一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead。
    
    根据表信息 可以推断出 变长长度列表和null值列表所占用的大小

### 行溢出后，mysql如何处理

    溢出页的地址(20字节)+ 溢出页
    