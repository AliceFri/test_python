

### 1. 索引的代价
    空间上， 每个索引都要建立一颗B+树

### 2. 时间上的代价
    数据上的增删改， 都需要去修改各个B+树索引，

### 3. 索引使用上的注意
    全值匹配: 搜索条件中的列和索引列一致

    左值匹配： 只包含索引左边部分的值

    匹配列前缀： 字符串 like 'A%';  like '%A%' (用不上索引)
        经常用到后序匹配查询的，可以存倒序进数据库, 然后前序匹配 （或者字符集排序规则看看有没有合适的）

    匹配范围值：
        如果对多个列同时进行范围查找的话,只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引
        或者 精准匹配左列，然后范围查询接下来的列

    用于排序：
        注意如果出现了filesort就很慢。 

    最好在查询列表里只包含索引列 （避免回表）

用不到索引的情况：
    1. ASC DESC混用（即多列按照跟索引顺序不一致的顺序）
    规定使用联合索引的各个排序列的排序顺序必须是一致的。

    2. WHERE 子句中出现非排序使用到的索引列
    
    3. 排序列包含非同一个索引的列

    4. 排序列使用了复杂的表达式 （如: UPPER）

### 2. 回表的代价
会使用到两个 B+ 树索引,一个二级索引,一个聚簇索引。
访问二级索引使用 顺序I/O ,访问聚簇索引使用 随机I/O 。

甚至让某些查询宁愿使用全表扫描也不使用 二级索引 。比
方说 name 值在 Asa ~ Barlow 之间的用户记录数量占全部记录数量90%以上,那么如果使用
idx_name_birthday_phone_number 索引的话,有90%多的 id 值需要回表,这不是吃力不讨好么,还不如直接去
扫描聚簇索引(也就是全表扫描)。


### 3. 挑选索引 建立索引
    1. 只为用于搜索、排序或分组的列创建索引

    2. 列的基数 指的是某一列中不重复数据的个数。 最好为那些列的基数大的列建立索引,为基数太小列的建立索引效果可能不好

    3. 索引列的类型尽量小 （cpu查询比较更快， 空间损耗更小）

    4. 索引字符串值的前缀  只对字符串的前几个字符进行索引

    5. 让索引列在比较表达式中单独出现 WHERE my_col * 2 < 4；  WHERE my_col < 4/2；

    6. 让主键具有 AUTO_INCREMENT ,让存储引擎自己为表生成主键,而不是我们手动插入
    7. 避免冗余的索引