

### 1. 现象

    循环永动机?

```
    func main() {
        arr := []int{1, 2, 3}
        for _, v := range arr {
            arr = append(arr, v)
            fmt.Println(arr, v)
        }
        fmt.Println(arr)
    }
```
    我们在遍历切片时追加的元素不会增加循环的执行次数，所以循环最终还是停了下来。 之后arr为[1, 2, 3, 1, 2, 3]


    神奇的指针
    在遍历一个数组时，如果获取 range 返回变量的地址并保存到另一个数组或者哈希时; 保存的是同一个地址;

```
    func main() {
        arr := []int｛1, 2, 3｝
        newArr := []*int{}
        for _, v := range arr {
            newArr = append(newArr, &v)
        }
        fmt.Println(newArr)
    }
```

    遍历清空数组
    编译器会直接使用 runtime.memclrNoHeapPointers 清空切片中的数据(优化)
```
    func main() {
	    arr := []int{1, 2, 3}
	    for i, _ := range arr {
	    	arr[i] = 0
	    }
    }
```

    随机遍历
    Go 语言在运行时为哈希表的遍历引入了不确定性，也是告诉所有 Go 语言的使用者，程序不要依赖于哈希表的稳定遍历。


### 2. 经典循环
    初始化循环的 Ninit；
    循环的继续条件 Left；
    循环体结束时执行的 Right；
    循环体 NBody：
    for Ninit; Left; Right {
        NBody
    }

### 3. for-range循环
    会转换成 经典for循环

    数组和切片: 

    对于所有的 range 循环，Go 语言都会在编译期将原切片或者数组赋值给一个新变量 ha，在赋值的过程中就发生了拷贝，
    而我们又通过 len 关键字预先获取了切片的长度，所以在循环中追加新的元素也不会改变循环执行的次数，这也就解释了循环永动机一节提到的现象。

    而遇到这种同时遍历索引和元素的 range 循环时，
    Go 语言会额外创建一个新的 v2 变量存储切片中的元素，循环中使用的这个变量 v2 会在每一次迭代被重新赋值而覆盖，赋值时也会触发拷贝。
    因为在循环中获取返回变量的地址都完全相同（因为后面是被重新复制而覆盖，所以地址不变），所以会发生神奇的指针一节中的现象。

    哈希表：
    首先会选出一个绿色的正常桶开始遍历，随后遍历所有黄色的溢出桶，最后依次按照索引顺序遍历哈希表中其他的桶，直到所有的桶都被遍历完成。

    字符串: 遍历时会获取字符串中索引对应的字节并将字节转换成 rune
    
### 4. 小结
    这一节介绍的两个关键字 for 和 range 都是我们在学习和使用 Go 语言中无法绕开的，
    通过分析和研究它们的底层原理，让我们对实现细节有了更清楚的认识，
    包括 Go 语言遍历数组和切片时会复用变量、哈希表的随机遍历原理以及底层的一些优化，
    这都能帮助我们更好地理解和使用 Go 语言。
