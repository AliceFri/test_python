

### 1. 现象

作用域
    1. defer 传入的函数不是在退出代码块的作用域时执行的，它只会在当前函数和方法返回之前被调用。

预计算参数
    2. defer 函数参数 会预计算, 并不是在退出时再计算。

栈   
    3. defer 关键字的插入顺序是从后向前的，而 defer 关键字执行是从前向后的，这也是为什么后调用的 defer 会优先执行。

### 2. 数据结构
    _defer 链表


我们在本节前面提到的两个现象在这里也可以解释清楚了：

后调用的 defer 函数会先执行：
后调用的 defer 函数会被追加到 Goroutine _defer 链表的最前面；
运行 runtime._defer 时是从前到后依次执行；

函数的参数会被预先计算；
调用 runtime.deferproc 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；