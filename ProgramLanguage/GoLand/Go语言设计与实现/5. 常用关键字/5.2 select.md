### 1. 介绍

    C 语言的 select 系统调用可以同时监听多个文件描述符的可读或者可写的状态，
    Go 语言中的 select 也能够让 Goroutine 同时等待多个 Channel 可读或者可写，在多个文件或者 Channel状态改变之前，select 会一直阻塞当前线程或者 Goroutine。

    select 是与 switch 相似的控制结构，与 switch 不同的是，
    select 中虽然也有多个 case，但是这些 case 中的表达式必须都是 Channel 的收发操作。
    下面的代码就展示了一个包含 Channel 收发操作的 select 结构：

    func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c <- x:
			x, y = y, x+y
		case <-quit:
			fmt.Println("quit")
			return
		    }
	    }
    }

    当 select 中的两个 case 同时被触发时，会随机执行其中的一个。

### 2. 现象
    1. select 能在 Channel 上进行非阻塞的收发操作；
    2. select 在遇到多个 Channel 同时响应时，会随机执行一种情况；(随机的引入, 避免饥饿问题的发生)

    可以通过 default 实现非阻塞; 当所有case都未被触发， 则直接执行 default 中的代码

### 3. 原理
    
    select结构不包含任何 case; 转换为直接调用runtime.block; 会直接阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态。

    一个Case; 会改写成if条件语句; 如果case中channel 为nil时, block; 

    非阻塞 ： default 


### 4. 小结

    我们简单总结一下 select 结构的执行过程与实现原理，首先在编译期间，Go 语言会对 select 语句进行优化，它会根据 select 中 case 的不同选择不同的优化路径：

    空的 select 语句会被转换成调用 runtime.block 直接挂起当前 Goroutine；
    如果 select 语句中只包含一个 case，编译器会将其转换成 if ch == nil { block }; n; 表达式；
        首先判断操作的 Channel 是不是空的；
        然后执行 case 结构中的内容；
    如果 select 语句中只包含两个 case 并且其中一个是 default，那么会使用 runtime.selectnbrecv 和 runtime.selectnbsend 非阻塞地执行收发操作；
    在默认情况下会通过 runtime.selectgo 获取执行 case 的索引，并通过多个 if 语句执行对应 case 中的代码；
    在编译器已经对 select 语句进行优化之后，Go 语言会在运行时执行编译期间展开的 runtime.selectgo 函数，该函数会按照以下的流程执行：

        随机生成一个遍历的轮询顺序 pollOrder 并根据 Channel 地址生成锁定顺序 lockOrder；
        根据 pollOrder 遍历所有的 case 查看是否有可以立刻处理的 Channel；
        如果存在，直接获取 case 对应的索引并返回；
        如果不存在，创建 runtime.sudog 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 runtime.gopark 挂起当前 Goroutine 等待调度器的唤醒；
        当调度器唤醒当前 Goroutine 时，会再次按照 lockOrder 遍历所有的 case，从中查找需要被处理的 runtime.sudog 对应的索引；

    select 关键字是 Go 语言特有的控制结构，它的实现原理比较复杂，需要编译器和运行时函数的通力合作。