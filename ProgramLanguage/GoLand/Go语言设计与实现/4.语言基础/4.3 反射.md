

### 0. 概念

    reflect 实现了运行时的反射能力，能够让程序操作不同类型的对象

    1. reflect.TypeOf 能获取类型信息；
    2. reflect.ValueOf 能获取数据的运行时表示

type Type interface {
Align() int
FieldAlign() int
Method(int) Method
MethodByName(string) (Method, bool)
NumMethod() int
...
Implements(u Type) bool
...
}

type Value struct {
// 包含过滤的或者未导出的字段
}

func (v Value) Addr() Value
func (v Value) Bool() bool
func (v Value) Bytes() []byte

    我们通过 reflect.TypeOf、reflect.ValueOf 可以将一个普通的变量转换成反射包中提供的 reflect.Type 接口和 reflect.Value结构体，
    随后就可以使用反射包中的方法对它们进行复杂的操作。

### 1. 三大法则

    反射带来的灵活性是一把双刃剑，反射作为一种元编程方式可以减少重复代码2，但是过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢
    1. 从 interface{} 变量可以反射出反射对象；
        Go 语言的函数调用都是值传递的，所以变量会在函数调用时进行类型转换; 反射对象由interface{}来
    2. 从反射对象可以获取 interface{} 变量；
        反射对象还原； v := reflect.ValueOf(1);v.Interface().(int)
    3. 要修改反射对象，其值必须可设置；
        想要更新一个 reflect.Value，那么它持有的值一定是可以被更新的
        反射对象跟最开始的变量没有任何关系，那么直接修改反射对象无法改变原始变量，程序为了防止错误就会崩溃。
        
        先获取指针对应的 reflect.Value，再通过 reflect.Value.Elem 方法得到可以被设置的变量

### 2. 类型和值

### 3. 更新变量
    
    
4.3.6 小结 #
Go 语言的 reflect 包为我们提供了多种能力，包括如何使用反射来动态修改变量、
判断类型是否实现了某些接口以及动态调用方法等功能，通过分析反射包中方法的原理能帮助我们理解之前看起来比较怪异、令人困惑的现象。