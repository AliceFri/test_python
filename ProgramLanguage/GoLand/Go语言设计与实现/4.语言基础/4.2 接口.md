### 1. 概念
    Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。

    接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，
    解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。

    
    隐式接口：
        Go 语言中接口的实现都是隐式的，我们只需要实现 Error() string 方法就实现了 error 接口

    类型：
        接口也是 Go 语言中的一种类型，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束。（编译期间完成类型检查）

    指针和接口:
        结构体实现接口/指针实现接口
        Go 语言的编译器会在结构体类型和指针类型都实现一个方法时报错 “method redeclared”。
    

    type Cat struct {}
    type Duck interface { ... }

    func (c  Cat) Quack {}  // 使用结构体实现接口
    func (c *Cat) Quack {}  // 使用结构体指针实现接口

    var d Duck = Cat{}      // 使用结构体初始化变量
    var d Duck = &Cat{}     // 使用结构体指针初始化变量

    编译器可以隐式的对变量解引用（dereference）获取指针指向的结构体；
==当我们使用指针实现接口时，只有指针类型的变量才会实现该接口；当我们使用结构体实现接口时，指针类型和结构体类型都会实现该接口== 

    nil 和 non-nil:
        func NilOrNot(v interface{}) bool {
	        return v == nil
        }
        调用 NilOrNot 函数时发生了隐式的类型转换，除了向方法传入参数之外，变量的赋值也会触发隐式类型转换。在类型转换时，
        *TestStruct 类型会转换成 interface{} 类型，转换后的变量不仅包含转换前的变量，还包含变量的类型信息 TestStruct，所以转换后的变量与 nil 不相等。

### 2. 数据结构

// interface{}
type eface struct { // 16 字节
	_type *_type
	data  unsafe.Pointer
}

// 含有方法的接口 底层数据结构
type iface struct { // 16 字节
	tab  *itab
	data unsafe.Pointer
}

type itab struct { // 32 字节
	inter *interfacetype
	_type *_type
	hash  uint32
	_     [4]byte
	fun   [1]uintptr
}


### 3. 类型转换
    

### 4. 类型断言
    
func main() {
	var c Duck = &Cat{Name: "draven"}
	switch c.(type) {
	case *Cat:
		cat := c.(*Cat)
		cat.Quack()
	}
}

### 5. 动态派发
	编译期不确定使用接口的哪个实现;
	

使用结构体实现接口带来的开销会大于使用指针实现，而动态派发在结构体上的表现非常差，这也提醒我们应当尽量避免使用结构体类型实现接口。

使用结构体带来的巨大性能差异不只是接口带来的问题，带来性能问题主要因为 Go 语言在函数调用时是传值的，动态派发的过程只是放大了参数拷贝带来的影响。