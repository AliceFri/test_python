[//]: # (https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/)
### 1. 基本原语

    这些基本原语提供了较为基础的同步功能，但是它们是一种相对原始的同步机制，在多数情况下，我们都应该使用抽象层级更高的 Channel 实现同步。

#### 1.1 Mutex 互斥锁
    
    sync.Mutex 由两个字段 state 和 sema 组成; state 表示当前互斥锁的状态, sema 用于控制锁状态的信号量。

    状态: 最低三位分别表示 mutexLocked（锁定状态）  mutexWoken（唤醒） mutexStarving（饥饿模式） waitersCount(等待的Goroutine个数)

        waitersCount + starving + woken + locked;

    模式：   正常模式： 锁的等待者按照先进先出的顺序获取锁(刚被唤醒的goroutine 竞争不过 新创建的 goroutine) （一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式。）
            饥饿模式： 互斥锁会直接交给等待队列最前面的 Goroutine。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。
    
    与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。

    加锁： 
        1. 当锁的状态是0, 设置为1. CAS 原子操作
        2. 如果互斥锁处于 mutexLocked 状态并且在普通模式下工作，会进入自旋，执行 30 次 PAUSE 指令消耗 CPU 时间等待锁的释放；
        3. 如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；
        4. 互斥锁会将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；
        5. 如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式

    解锁：
        1. 当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 mutexLocked 标志位；
        2. 当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；
        在其他情况下会通过 sync.runtime_Semrelease 唤醒对应的 Goroutine；

#### 1.2 RWMutex  读写互斥锁
