
### 1. 介绍

    上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。

    type Context interface {
	    Deadline() (deadline time.Time, ok bool)        // 返回context被取消的时间， 也就是完成工作的截止日期
	    Done() <-chan struct{}                          // 返回一个channel, 这个channel在工作完成或者上下文被取消后关闭; 多次调用会返回同一个channel
	    Err() error                                     // 返回结束的原因，只会在Done方法对应的channel关闭时 返回非空的值； Canceled / DeadlineExceeded
	    Value(key interface{}) interface{}              // 获取键对应的值
    }

### 2。原理

    我们可能会创建多个 Goroutine 来处理一次请求，
    而 context.Context 的作用是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。

    每一个 context.Context 都会从最顶层的 Goroutine 一层一层传递到最下层。
    context.Context 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。

    多个 Goroutine 同时订阅 ctx.Done() 管道中的消息，
    一旦接收到取消信号就立刻停止当前正在执行的工作。


### 3. 默认上下文
    1. context.Background、context.TODO 这两个方法都会返回预先初始化好的私有变量 background 和 todo

    从源代码来看，context.Background 和 context.TODO 也只是互为别名，没有太大的差别，只是在使用和语义上稍有不同：

        context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；
        context.TODO 应该仅在不确定应该使用哪种上下文时使用；

### 4. 取消信号
    context.WithCancel 函数能够从 context.Context 中衍生出一个新的子上下文并返回用于取消该上下文的函数。
    一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。

    context.WithDeadline 和 context.WithTimeout 也都能创建可以被取消的计时器

### 5. 传值方法
        
    在最后我们需要了解如何使用上下文传值，context 包中的 context.WithValue 能从父上下文中创建一个子上下文，传值的子上下文使用 context.valueCtx 类型：

func WithValue(parent Context, key, val interface{}) Context {
	if key == nil {
		panic("nil key")
	}
	if !reflectlite.TypeOf(key).Comparable() {
		panic("key is not comparable")
	}
	return &valueCtx{parent, key, val}
}
    
    context.valueCtx 结构体会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，它只会响应 context.valueCtx.Value 方法，该方法的实现也很简单：

type valueCtx struct {
	Context
	key, val interface{}
}

func (c *valueCtx) Value(key interface{}) interface{} {
	if c.key == key {
		return c.val
	}
	return c.Context.Value(key)
}

    如果 context.valueCtx 中存储的键值对与 context.valueCtx.Value 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到某个父上下文中返回 nil 或者查找到对应的值。


### 6. 总结
    Go 语言中的 context.Context 的主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用，
    虽然它也有传值的功能，但是这个功能我们还是很少用到。

    在真正使用传值的功能时我们也应该非常谨慎，使用 context.Context 传递请求的所有参数一种非常差的设计，
    比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。