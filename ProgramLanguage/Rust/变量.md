

### 变量

    1. 默认情况下 Rust 变量是不可变的, 声明时加上 mut 使其可变， 但不可变其类型。


### 常量

    const PI: u32 = 3;

    自始至终不可变， 且必须注明 类型； 不能通过调用函数或者运行时计算得到复制。

### 遮蔽

    可以声明和前面变量具有相同名称的新变量， 使用 let 关键字来遮蔽变量, 可以改变变量的类型；

---------

### 数据类型

    Rust 是一种静态类型（statically typed）的语言，这意味着它必须在编译期知道所有变量的类型。
    
    let guess: u32 = "42".parse().expect("Not a number!");  # 不能推导出类型时, 必须加一个 类型标注

#### 标量类型

    整型： i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, isize, usize
        避免 Rust 整型 溢出包裹
        使用 wrapping_* 方法在所有模式下进行包裹，例如 wrapping_add
        如果使用 checked_* 方法时发生溢出，则返回 None 值
        使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
        使用 saturating_* 方法使值达到最小值或最大值
    
    浮点型： f32, f64
    
        基本运算符号： + - * /(整数除法会向下取整) % 

    布尔型: true false

    字符类型：char, 单引号括起来(4个字节， 可表示不止ASCII码)  字符串是双引号括起来
            区分 字符串字面量
            区分 String 类型

#### 复合类型

    元组： 长度固定，元组的每个位置都有一个类型。 let tup: (i32, f64, u8) = (500, 6.4, 1);
            let x: (i32, f64, u8) = (500, 6.4, 1);
            let (x1, y1, z1) = x;
            let five_hundred = x.0;
            let six_point_four = x.1;   
            let one = x.2;
    数组： 每个元素必须具有相同的类型， Rust中的数组也具有固定长度
            let a: [i32; 5] = [1, 2, 3, 4, 5];
            let a = [3; 5];
            let first = a[0];
            let second = a[1];

-----------

### 函数


