https://rustwiki.org/zh-CN/book/ch00-00-introduction.html
### Rust 最与众不同的特性， 让Rust无需垃圾回收器，即可保证内存安全

### 语言管理内存的方式
    1. 开发者亲自分配和释放内存， C
    2. 垃圾回收机制   Java Python
    3. 所有权系统管理内存        Rust

### 栈 与 堆
    代码在运行时可供使用的内存

    栈中的数据必须占用已知且固定的大小

    栈 比堆 速度更快，因为访问位置总在栈顶

### 所有权规则

    1. Rust中的每一个值都有一个被称为其 所有者 的变量
    2. 值在 任一时刻 有且只有 一个所有者
    3. 当所有者（变量）离开作用域， 这个值将被丢弃

==内存在拥有它的变量离开作用域后就被自动释放==
当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，
在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。

###

[//]: # (String 有 ptr, len, capacity 3个属性)
    let s1 = String::from("hello");

[//]: # (s1 和 s2 都指向同一块内存区域)
[//]: # (为了避免 二次释放错误， Rust会认为s1不再生效， 若再调用s1会报错)
    let s2 = s1;

    Rust 永远也不会自动创建数据的 “深拷贝”。
    因此，任何 自动 的复制可以被认为对运行时性能影响较小。

----------

### 所有权与函数
   将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样
   
   函数返回值 可以 转移 所有权 
   
    在每一个函数中都获取所有权并接着返回所有权有些啰嗦。
    如果我们想要函数使用一个值但不获取所有权该怎么办呢？
    如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，
    我们也可能想返回函数体中产生的一些数据。

### 引用与借用 

    fn main() {
        let s1 = String::from("hello");

        let len = calculate_length(&s1);

        println!("The length of '{}' is {}.", s1, len);
    }

    fn calculate_length(s: &String) -> usize {
        s.len()
    }

    创建一个引用的行为 称为 "借用"。 无法通过引用修改内容/或者使用可变引用 &mut s;

    可变引用，在同一时间只有某一特定数据可以有一个可变引用。也 不能在拥有不可变引用的同时拥有可变引用。

    注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。
        fn main() {
            let mut s = String::from("hello");

            let r1 = &s; // 没问题
            let r2 = &s; // 没问题
            println!("{} and {}", r1, r2);
            // 此位置之后 r1 和 r2 不再使用

            let r3 = &mut s; // 没问题
            println!("{}", r3);
        }

引用的规则：
    1. 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
    2. 引用必须总是有效的。

### 切片 slice
    let s = String::from("hello world");
    let hello = &s[0..5];
    let world = &s[6..11];
    
    字符串字面量 也是一种字符串slice
    slice 是 一种类型的不可变引用
